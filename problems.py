# -*- coding: utf-8 -*-
"""Untitled3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/12MUyQvgK08XarwBZGtWkhBQaejPqQ03A
"""

# Interview based question

"""**#Ritesh s savale**

**What is the difference between list and tuple in Python?**
"""

# list are mutable in nature / Tuple are immutable in nature.
# list are represented by "[]" and Tuple are represented by "()".
list2=[1,2,3]
print(list2)
list2.extend([4,5,6]) #mutable
print(list2)
# Tuple
tup=(1,2,3)
print(tup)

"""**Explain the concept of PEP 8.**"""

'''
PEP 8, which stands for "Python Enhancement Proposal 8," is the style guide for Python code.
1. Indentation:
 Use 4 spaces for each level of indentation.

2.Maximum Line Length:
 Limit lines to 79 characters for code and 72 for docstrings/comments.

3.Imports:
# Separate imports into groups (standard library, third-party, local).
Avoid wildcard imports.
Whitespace:

4.Avoid extraneous whitespace.
Separate functions/classes with two blank lines.
Comments:

5.Use inline comments sparingly.
Write comments in complete sentences.
Naming Conventions:

6.Use lowercase with underscores for function/variable names.
Use CamelCase for class names.
Use uppercase with underscores for constants.

7.Whitespace Between Statements:
Use blank lines sparingly.

8.Docstring Conventions:
Use triple double-quotes for docstrings.
Write docstrings for all public modules, functions, classes, and methods.'''

"""#**What is the purpose of the __init__ method in Python classes?**"""

# It is used to invoke the object .
# The __init__ method is a special method, also known as a constructor, that is automatically called when an object of a class is created. Its primary purpose is to initialize the attributes of the object. The name __init__ stands for "initialize."

class Dog:
    def __init__(self, name, age):
        # Instance variables (attributes) initialized in the __init__ method
        self.name = name
        self.age = age

# Creating an instance of the class
my_dog = Dog(name="Buddy", age=3)

# Accessing the attributes of the object
print("Name:", my_dog.name)  # Output: Buddy
print("Age:", my_dog.age)    # Output: 3

"""**How does inheritance work in Python? Provide an example.**"""

# Inheritance is a fundamental concept in object-oriented programming (OOP) that allows a class (called the subclass or derived class) to inherit attributes and methods from another class (called the superclass or base class). This promotes code reuse and enables the creation of a hierarchy of classes.

# In Python, a subclass is created by specifying the superclass in parentheses after the class name. The subclass inherits all attributes and methods of the superclass and can also have its own additional attributes and methods.

# Here's a simple example to illustrate inheritance in Python:

#example
# Superclass (Base class)
class Animal:
    def __init__(self, name):
        self.name = name

    def make_sound(self):
        pass

# Subclass (Derived class)
class Dog(Animal):
    def make_sound(self):
        return "Woof!"

# Subclass (Derived class)
class Cat(Animal):
    def make_sound(self):
        return "Meow!"

# Creating instances of the subclasses
dog_instance = Dog("Buddy")
cat_instance = Cat("Whiskers")

# Accessing attributes and methods
print(f"{dog_instance.name} says: {dog_instance.make_sound()}")
print(f"{cat_instance.name} says: {cat_instance.make_sound()}")

# In this example:

# The Animal class is the superclass, and it has an __init__ method to initialize the name attribute and a make_sound method, which is a placeholder method to be implemented by subclasses.

# The Dog and Cat classes are subclasses of Animal. They inherit the __init__ method and the make_sound method from the Animal class.

# The make_sound method is overridden in both the Dog and Cat subclasses to provide specific implementations for each type of animal.

# Instances of Dog and Cat are created, and their attributes and methods are accessed.

"""**Explain the difference between staticmethod and classmethod.**"""

# staticmethod:

# A staticmethod is a method that is bound to a class rather than an instance of the class.
# It doesn't have access to the instance or the class itself, and it doesn't take self or cls as its first parameter.
# It is defined using the @staticmethod decorator or the staticmethod() built-in function.
# staticmethod is typically used for utility functions that are related to the class but don't depend on instance-specific or class-specific attributes.

#classmethod
#A classmethod is a method bound to the class and takes the class itself (cls) as its first parameter.
# It can access and modify class-level attributes but not instance-specific attributes.
# It is defined using the @classmethod decorator.
# classmethod is often used when you want to perform some operation that involves the class itself, such as creating an instance of the class or accessing class-level variables.

"""**What is Polymorphism in Python? Give an example.**"""

# poly means many and morphism means forms .
# so basically same thing can be represented/implemented in a multiple ways
# here are two main types of polymorphism:
# Compile-time Polymorphism (Static Binding or Method Overloading): This occurs when the method that needs to be executed is determined at compile time. It is achieved through method overloading, where multiple methods with the same name exist in the same class, but with different parameter lists.
# Runtime Polymorphism (Dynamic Binding or Method Overriding): This occurs when the method that needs to be executed is determined at runtime. It is achieved through method overriding.

# example
class Shape:
    def area(self): pass

class Circle(Shape):
    def __init__(self, radius): self.radius = radius
    def area(self): return 3.14 * self.radius ** 2

class Rectangle(Shape):
    def __init__(self, width, height): self.width, self.height = width, height
    def area(self): return self.width * self.height

def calculate_area(shape): return shape.area()

# Instances and function calls
circle_instance, rectangle_instance = Circle(radius=5), Rectangle(width=4, height=6)
print("Area of the circle:", calculate_area(circle_instance))
print("Area of the rectangle:", calculate_area(rectangle_instance))

"""**How do you handle exceptions in Python?**

"""

# In python exception can be handle by using try ,except,else,finally block
# The try block contains the code that might raise an exception.
# The except block(s) specify the code to be executed if a particular exception occurs. You can have multiple except blocks to handle different types of exceptions.
# The else block contains code that will be executed if no exception is raised in the try block.
# The finally block contains code that will be executed no matter what, whether an exception occurred or not.

try:
    num = int(input("Enter a number: "))
    result = 10 / num
except ValueError:
    print("Error: Please enter a valid number.")
except ZeroDivisionError:
    print("Error: Cannot divide by zero.")
else:
    print("Result:", result)
finally:
    print("Program execution completed.")

"""**Explain the Global Interpreter Lock (GIL) in Python.**"""

# The Global Interpreter Lock (GIL) in CPython restricts simultaneous execution of Python threads, limiting parallelism in CPU-bound tasks. While it simplifies memory management, it can hinder performance. For CPU-bound operations, multiprocessing or alternative Python implementations without a GIL are preferable, while I/O-bound tasks benefit from threading.

"""**What is a decorator in Python? Provide an example**"""

#  decorator is a design pattern that allows you to extend or modify the behavior of functions or methods without changing their actual code
# Decorators are applied using the @decorator syntax. They are commonly used for tasks like logging, memoization, access control, or modifying function behavior.
# Decorators provide a clean and reusable way to modify or extend the behavior of functions or methods in a flexible manner. They are widely used in Python for tasks like logging, caching, and aspect-oriented programming.


# example
# Decorator function
def uppercase_decorator(func):
    def wrapper(*args, **kwargs):
        result = func(*args, **kwargs)
        return result.upper()
    return wrapper

# Applying the decorator
@uppercase_decorator
def greet(name):
    return f"Hello, {name}!"

# Calling the decorated function
result = greet("Alice")
print(result)

"""**# How do you implement encapsulation in Python?**"""

class Counter:
    def __init__(self):
        self._count = 0  # Protected attribute

    def increment(self):
        self._count += 1

    def get_count(self):
        return self._count


counter = Counter()

# Accessing protected attribute
print("Initial Count:", counter.get_count())

# Modifying protected attribute using public method
counter.increment()
print("Updated Count:", counter.get_count())

"""**# Explain the concept of duck typing.**"""

# ocuses on the behavior of objects rather than their explicit type or class. In duck typing, an object's suitability for a particular operation is determined by whether it supports the necessary methods or properties, rather than its actual type or class.

"""**What is the difference between append() and extend() methods for lists?**"""

# append() adds a single element to the end of the list.
# extend() adds elements from an iterable or multiple elements to the end of the list.

# append
list1=[2,3,4]
list1.append(7)
print(list1)
# extend
list2=[2,3,4,5]
list2.extend([6,7,8])
print(list2)

"""**Discuss the use of self in Python classes.**"""

# In Python, self is a reference to the instance of a class. It is a conventional name for the first parameter of instance methods in Python classes. When you call a method on an instance, Python automatically passes the instance as the first parameter to the method, and by convention, this parameter is named self. The purpose of self is to allow the instance to refer to itself and access its attributes and methods.

"""****

**Explain the purpose of the __slots__ attribute.**
"""

# The __slots__ attribute in Python is used to explicitly declare the attributes (instance variables) that a class can have. By defining __slots__, you are restricting the set of attributes that instances of the class can have, which can lead to memory efficiency and some performance improvements. This attribute is a tuple of strings representing the allowed attribute names.

class Point:
    __slots__ = ('x', 'y')

    def __init__(self, x, y):
        self.x = x
        self.y = y

# Creating instances of the class
point1 = Point(x=1, y=2)
point2 = Point(x=3, y=4)

# Accessing attributes
print(point1.x, point1.y)

#In this example, the Point class uses __slots__ to restrict instances to having only 'x' and 'y' attributes. This can lead to memory savings and helps prevent accidental creation of new attributes.

"""**What is the difference between an instance variable and a class variable?**"""

# Instance Variable: Belongs to an instance of a class, and each instance has its own copy. Defined inside the constructor method using self.

# Class Variable: Belongs to the class itself and is shared among all instances of the class. Defined outside any method at the top level of the class.

# Instance variable
class Car:
    def __init__(self, brand, model):
        self.brand = brand  # Instance variable
        self.model = model  # Instance variable

# Creating instances of the class
car1 = Car(brand="Toyota", model="Camry")
car2 = Car(brand="Honda", model="Accord")

print(car1.brand)  # Output: Toyota
print(car2.brand)  # Output: Honda

# Class variable

class Circle:
    pi = 3.14  # Class variable

    def __init__(self, radius):
        self.radius = radius  # Instance variable

# Creating instances of the class
circle1 = Circle(radius=5)
circle2 = Circle(radius=3)

print(circle1.pi)  # Output: 3.14
print(circle2.pi)  # Output: 3.14